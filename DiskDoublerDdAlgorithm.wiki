#summary Reverse-engineered specs for the DD algorithm from DiskDoubler

=Introduction=

DD is a compression algorithm used by the old DiskDoubler application for Mac OS. It compresses the data stream as a series of blocks of variable size (up to a maximum of 0x1010e?).

DD is an LZSS-like algorithm that splits the literals and offsets into two separate streams, in addition to a third stream for the lengths of literal runs and matches. All three streams are (optionally, for some) Huffman encoded.

=Decoding=

==Block header==

Each block starts with a 22-byte header. Its layout is as follows:

|| *Offset* || *Size* || *Meaning* ||
|| 0 || 4 || Uncompressed size ||
|| 4 || 2 || Number of literals ||
|| 6 || 2 || Number of offsets ||
|| 8 || 2 || Compressed size of offsets ||
|| 10 || 2 || Compressed size of literals ||
|| 12 || 2 || Compressed size of run lengths ||
|| 14 || 1 || Flags ||
|| 15 || 1 || Unused? ||
|| 16 || 1 || XOR sum of compressed offsets ||
|| 17 || 1 || XOR sum of compressed literals ||
|| 18 || 1 || XOR sum of compressed run lengths ||
|| 19 || 1 || XOR sum of uncompressed data ||
|| 20 || 1 || Unused? ||
|| 21 || 1 || XOR sum of preceeding 21 bytes ||

Flags: Bit 6 indicates whether the block is _un_compressed. Bit 7 indicates whether the literals block is compressed.

The following block data consists of the offset, literal and run length streams. Each one is as many bytes as the compressed size field for each indicates.

==Huffman coding==

All stream use the same kind of Huffman coding. The Huffman parameters are transmitted at the start of each individual stream. Only the lengths of the codes are stored. The Huffman header starts with a 32-bit value that defines parameters for the code:

|| *Bits* || 31-24 || 23-13 || 12-8 || 7-3 || 2 || 1 || 0 ||
|| *Meaning* || Number of entries minus one || Total number of bits in header (not counting these 32 bits) || Max code length || Bits per code length || Uses zero coding || || ||

This is followed by a list of code lengths for each entry. The "number of entries" field in the header indicates how many there are, up to a maximum of 256. If the "uses zero coding" bit is 0, each entry is just a bit string as long as the "bits per code length" field indicates, and gives the length of the Huffman code for that entry. If the "uses zero coding" bit is 1, each entry is preceded by a single bit. If this bit is 0, the code length for this entry is 0 (that is, it is unused), and that is all the data that is stored for that entry. If the bit is 1, it is followed by a bit string of the length given by the "bits per code length" field giving the code length.

The data stream starts at the bit offset given by the "total number of bits" field, plus 32 bits for the header. It is not necessarily aligned on a byte border.

==Offset stream==



==Literal stream==

The literal stream contains of all literal bytes of the compressed stream. Depending on bit 7 of the flag field, it is either uncompressed (if the bit is 0) or compressed using Huffman coding (if the bit is 1). If it is uncompressed, then the "number of literals" field should be equal to the "compressed size of literals" field.

==Run length stream==

The run length stream contains a series of 8 bit run length codes encoded using Huffman coding. To decode the final output stream, start a loop that does the following:

  * Read a length code from the bit stream using the Huffman coding.
  * If the code is 0, copy a single byte from the literal stream to the output.
  * If the code is less than 128, read an offset from the offset stream, then copy as many bytes as the code plus two (maybe) from the previous output to the output.
  * If the code is 128 or larger, subtract 128, multiply by two, and copy that many bytes from the literal stream to the output.

==Steam footer==