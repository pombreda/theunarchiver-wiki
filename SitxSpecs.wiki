#summary Reverse-engineered specs for the sitx format.

= Marker =

StuffIt X files begin with `StuffIt!` or `StuffIt?`.

= Header =

== P2 Universal Code ==

Many values in StuffIt X files are encoded using a universal code apparently called "P2". These values can be decoded as follows:

  * Read and count bits, stopping when you encounter a 0 bit.
  * The number of bits read (including the final 0) is the number of 1 bits in the value.
  * Read bits until you have read as many 1 bits as the previously determined count.
  * The final value is the value encoded by this bit string, interpreted as starting with the least significant bit, minus 1.

Bits are read starting from the least significant bit of every successive byte, similarly to the Zip format.

=== Examples ===

  * 0: 0 1
  * 1: 0 01
  * 2: 10 11
  * 3: 0 001
  * 4: 110 101
  * 5: 110 011
  * 6: 1110 111
  * 14: 11110 1111
  * 15: 0 00001
  * 16: 10 10001


== Elements ==

The main data in the header is encoded as a series of "elements". These are identified by a numerical ID, and contain a series of flags followed by a possible data section. An element header is parsed as follows:

  * Synchronize to a byte boundary.
  * Read a single bit flag (meaning unknown).
  * Read the element ID as a P2 value.
  * Loop through the flags:
    * Read a flag key as a P2 value.
    * If the key is 0, stop the loop.
    * Otherwise, read the flag value as a P2 value.
  * Loop through the algorithm list:
    * Read an algorithm key as a P2 value.
    * If the key is 0, stop the loop.
    * Otherwise, read the algorithm value as a P2 value.
      * If the key is 4, read a second P2 value.

This may be followed by further data, and a data payload.

=== Meaning of the flags ===

  * Flag 1 seems to be some kind of ID number.
  * Flag 2 seems to be a parent reference, giving the ID number of the parent element.
  * Flag 3 seems to also be some kind of reference.
  * Flag 5 seems to be a length attribute. It can appear both on elements with and without a data payload. On elements with data payloads it seems to give the uncompressed size of the payload.

=== Meaning of the algorithm list ===

  * Key 1 seems to be the algorithm used.
    * 0 is SitxBrimstoneAlgorithm.
    * 1 is SitxCyanideAlgorithm.
    * 2 might be SitxDarkhorseAlgorithm.
    * 3 might be Deflate (or some other LZ+Huffman algorithm)?
    * 4 is some kind of BWT algorithm, perhaps SitxIronAlgorithm.
    * 5 is unknown, possibly "Blend", a per-block combination of the other algorithms.
    * 6 is unknown.

=== Element types ===

|| *Element ID* || *Name* || *Contents* || *Data payload*|| *Meaning* ||
|| 0 || End || || No || End of archive ||
|| 1 || Data || || Yes || A data stream ||
|| 2 || File || || No || Defines a file in the directory tree structure. Parent flag gives the parent directory. ||
|| 3 || Fork || 1*P2 ||No || Ties a data stream to a file. Parent flag gives the file, flag 3 gives the data stream, flag 5 the length of the data (might not be same as the length of the data stream - solid archives?). The P2 value defines whether this is a data (0) or resource (1) fork. ||
|| 4 || Directory || || No || Defines a directory in the directory tree structure. Parent flag gives the parent directory. ||
|| 5 || Catalog || || Yes || Defines all metadata for the directory tree. Usually compressed with method 0. ||
|| 6 || Clue || N bytes || No || Contains N bytes, starting at the next byte boundary, where N is given by the length flag, 5. ||
|| 7 || Root || 1*P2 || No || ||
|| 8 || Boundary || || No || ||
|| 9 || ? || || ? || ||
|| 10 || Receipt || || ? || ||
|| 11 || Index || || Yes || ||
|| 12 || Locator || || Yes || ||
|| 13 || ID || || Yes || ||
|| 14 || Link || || Yes || ||
|| 15 || Segment index || || Yes || ||
|| >10 || || || Yes || All elements larger than 10 seem to have a data payloadÂ ||

== Data block streams ==

Some elements contain a data stream. This is encoded as series of blocks. Each block is preceeded by the block size encoded as a P2 value. This value is always placed on a byte boundary, and the following data also starts at a byte boundary. If the length is 0, this marks the end of the stream. Apparently, every data-containing block contains two of these data streams. The streams may be of zero length.

= Compression algorithms =

  * Known compression methods:
    * "brimstone": SitxBrimstoneAlgorithm
    * "cyanide": SitxCyanideAlgorithm
    * "darkhorse"
      * Uses range coder.
      * Encodes "distance", "length", "literal", "recency" ("symbol"?)
    * "iron"
      * BWT-based
    * "blend" - Combines the three previous per-block?
    * deflate - Not sure if this is used, but exists.
    * Various format-specific methods - mp3, jpeg, pdf (from v12)
  * Range coder: SitxRangeCoder